/**
 * File:    TheEquation.cga
 * Created: 11 Nov 2021 21:33:26 GMT
 * Author:  mozar
 */

version "2019.0"

import meterConverter: "meterToFeet2019.cga"
#import Waste_DensitybyBldClass:"rules/waste/Waste_DensitybyBldClass.cga"

##### CONSTANTS #####
const BalanceSpaceBuilding = 0.35

#Building Contants
const groundfloor_height = meterConverter.feet(15)
const secondfloor_height = meterConverter.feet(12)
const floor_height = meterConverter.feet(12)

# How Call attr Height of Waste_DensitybyBldClass???
#If not, below I am trying to define

##### ATTRIBUTES #####

@Enum("Low Walkup", "High Walkup", "Low High Rise", "Medium High Rise", "Dense High Rise") 
attr BldgClass = 
	50%: "Low Walkup"
	20%: "High Walkup"
	10%: "Low High Rise"
	5%: "Medium High Rise"
	else: "Dense High Rise" 

##### FUNCTIONS #####
BdlgHeight(BldgClass)= 
	case BldgClass == "Low Walkup" : rand(meterConverter.feet(12),meterConverter.feet(39))
	case BldgClass == "High Walkup" : rand(meterConverter.feet(39),meterConverter.feet(63))
	case BldgClass == "Low High Rise" : rand(meterConverter.feet(63), meterConverter.feet(111))
	case BldgClass == "Medium High Rise" : rand(meterConverter.feet(111),meterConverter.feet(243))
	case BldgClass == "Dense High Rise" : rand(meterConverter.feet(243),meterConverter.feet(363))
	else : 0

##### RULES #####
@StartRule
BdlgExtrusion-->
	extrude(BdlgHeight(BldgClass))
	split(y){ groundfloor_height : GroundFloorSelector | { ~floor_height : RestFloorSelector }* }
#	comp(f){ street.left : FacadeSplit }
	
#FacadeSplit-->
#	split(y){ groundfloor_height : GroundFloor | { ~floor_height : RestFloor }* }
	  		
Floors-->
	case (split.index == 0) : GroundFloorSelector
	else : RestFloorSelector

#############################
######GroundFloorRules####### 
GroundFloorSelector-->
	color("#FAD97D")
	comp(f){ bottom : GFFloorArea }
	
GFFloorArea -->
   print("total area = " + geometry.area)
   SplitAreaGroundFloorBldg
   
GroundFloor-->
	extrude (-(groundfloor_height))
	
SplitAreaGroundFloorBldg-->
	case BldgClass == "Low Walkup" : splitArea(x) { '0.3 : GroundFloor | '0.7 : NIL }
	case BldgClass == "High Walkup"  : splitArea(x) { '0.3 : GroundFloor | '0.7 : NIL }
	case BldgClass == "Low High Rise"  : splitArea(x) { '0.4 : GroundFloor | '0.6 : NIL }
	case BldgClass == "Medium High Rise"  : splitArea(x) { '0.5 : GroundFloor | '0.5 : NIL }
	case BldgClass == "Dense High Rise"  : splitArea(x) { '0.5 : GroundFloor | '0.5 : NIL }
	else: NIL
 
###########################	
######RestFloorRules####### 
RestFloorSelector-->
	color("#A3CCD1")
	comp(f){ bottom : RFFloorArea }
	
RFFloorArea -->
   print("total area = " + geometry.area)
   splitArea(x) { '0.9 : RestFloor | '0.1 : NIL }
	
RestFloor-->
	extrude (-(floor_height))	
	
SplitAreaRestFloorBldg-->
	case BldgClass == "Low Walkup" : splitArea(x) { '0.9 : RestFloor | '0.1 : NIL }
	case BldgClass == "High Walkup"  : splitArea(x) { '0.9 : RestFloor | '0.1 : NIL }
	case BldgClass == "Low High Rise"  : splitArea(x) { '0.8 : RestFloor | '0.2 : NIL }
	case BldgClass == "Medium High Rise"  : splitArea(x) { '0.75 : RestFloor | '0.25 : NIL }
	case BldgClass == "Dense High Rise"  : splitArea(x) { '0.75 : RestFloor | '0.25 : NIL }
	else: NIL
		
###########################	
######2FloorRules####### 

SplitArea2FloorBldg-->
	case BldgClass == "Low Walkup" : splitArea(x) { '0.8 : RestFloor | '0.2 : NIL }
	case BldgClass == "High Walkup"  : splitArea(x) { '0.8 : RestFloor | '0.2 : NIL }
	case BldgClass == "Low High Rise"  : splitArea(x) { '0.8 : RestFloor | '0.2 : NIL }
	case BldgClass == "Medium High Rise"  : splitArea(x) { '0.75 : RestFloor | '0.25 : NIL }
	case BldgClass == "Dense High Rise"  : splitArea(x) { '0.75 : RestFloor | '0.25 : NIL }
	else: NIL



#Facade-->
#	color("#CDCDCD")


	
#GroundFloorSelector-->
#comp
#negative extrude the 70% of the ground floor, rand


/* 	
BuildingFootprint-->
	extrude (Height)	


const BlockArea= 120000 #you dont need parenthesis
const DensityPerBlock= 6.5 #you dont need parenthesis
const EventDensity= 6 #you dont need parenthesis

#####Functions#####
BlockPopulationCalculator(BlockArea, DensityPerBlock)=
	BlockArea/DensityPerBlock
	
# first, separate the function into an attribute that can be recalculated on the fly.
attr blockPopulation = BlockPopulationCalculator(BlockArea, DensityPerBlock)

RequiredArea(blockPopulation, EventDensity) = # then pass the attribute to the new function. this gives you more flexibility
	blockPopulation*EventDensity
	
StreetArea(ST_WIDTH, SHAPE_Leng)=
	ST_WIDTH*SHAPE_Leng
	
BalanceSpaceArea(RequiredArea, StreetArea)=
	RequiredArea - StreetArea #added space for reading clarity


#####Rules#####
@StartRule
BalanceSpace-->
	#splitArea()
	color ("#edffc2")  
	*/	
 